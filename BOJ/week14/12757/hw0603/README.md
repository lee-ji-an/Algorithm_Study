## Info
[12757 전설의 JBNU](https://www.acmicpc.net/problem/12757)

## 💡 풀이 방법 요약
DB 자체는 딕셔너리 형태로 구현하여 데이터를 저장해 두고, Key들만 따로 정렬된 상태로 유지하여 임의의 `key` 값에 대해 근접한 키들을 빠르게 찾을 수 있도록 한다.  
DB에 값을 추가할 때 마다 `sortedkeys` 리스트에도 키 값을 저장해 주는데, 이때 `bisect.insort()`를 이용하여 항상 정렬된 리스트를 만들어 준다.  
근접한 키 값을 찾을 때는 `bisect.bisect_left()`를 활용하여 찾으면 된다. 찾은 인덱스 기준 좌 우의 값 두 가지를 비교하여 차이가 `K`값을 넘지 않으면서 좀 더 가까운 인덱스의 키를 찾아주면 되는데, `bisect_left()` 함수의 반환값 자체는 "정렬된 리스트에서 임의의 값을 삽입한다고 가정했을 때, 몇 번째 인덱스에 들어가면 될까?"를 의미하므로, 해당 값이 리스트 처음과 끝에 들어갈 것으로 예상되는 경우에는 분기하여 인덱스를 잘 맞춰 주어야 한다.

## 🙂 마무리
처음에 "가장 근접한 키"라는 단어를 보자 마자 이진탐색 + insort 생각이 나서 구현 자체는 빨리 했는데  
대문자 `K`랑 소문자 `k` 잘못 써서 두 시간 날렸다..
