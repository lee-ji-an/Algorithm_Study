## Info
[16236 아기 상어](https://www.acmicpc.net/problem/16236)

## 💡 풀이 방법 요약
먼저 물고기와 상어의 위치를 입력 받으면서 동시에 상어의 좌표와 물고기의 총 개수를 저장해 둔다.  
이 때, 상어의 위치(`9`)의 값은 차후 BFS를 적용할 때, **크기가 9인 물고기**로 인식하는 것을 방지하기 위하여 0으로 바꿔 준다.  
  
다음으로는 현재 상어의 위치 좌표를 전달받고, 먹을 수 있는 물고기 중 가장 가까운 물고기를 잡아먹은 후, 처음 위치로부터의 거리와 그 물고기를 잡아먹은 후 상어의 좌표를 반환하는 `bfs(row, col)` 함수를 정의한다.  
BFS 탐색에서는 현재의 경로가 항상 최적이라는 점을 이용한다. 다시 말해, 탐색 중 물고기를 한 번이라도 만나면 그 경로는 그 물고기까지의 최단경로가 된다. 반복 중 현재의 거리 최솟값보다 더 큰 경우는 조사할 필요가 없고(큐에 삽입할 필요 X), 최단거리가 동일한 물고기가 2마리 이상이라면 `row`값이 작은 물고기를, 거리와 `row`값이 동일하다면 `col`값도 비교하여 제일 작은 물고기를 선택하여 먹으면 된다.  
물고기 후보군 리스트(`candidate_list`)에 후보군 노드를 삽입할 때, `(거리, 행, 열)` 순으로 튜플을 만들어 삽입하면, `list.sort()`를 사용하여 우선순위를 쉽게 보존할 수 있다.  
  
`bfs()` 함수가 정의 되었다면 남아 있는 물고기가 존재하지 않을 때 까지 루프를 돌면서 `bfs()`를 반복 호출하여 물고기를 잡아먹음과 동시에 상어의 좌표를 이동시키고, 문제의 조건에 맞게 자신의 크기와 동일한 수의 물고기를 잡아먹었다면 상어의 크기를 1 성장시킨다.  
루프 안에서 한 번 상어가 위치했던 곳은 이미 물고기가 잡아먹혔으므로, 루프를 돌면서 원본 `matrix` 배열에서 해당 좌표를 0으로 바꿔 주어야 한다.  
루프는 `bfs()`가 `False`를 반환한 경우(남아있는 물고기가 있지만 더 이상 잡아먹을 수 있는 물고기가 없을 경우) 또는 `fish_cnt`가 0이 되는 경우(더 이상 남아 있는 물고기가 없는 경우) 탈출하고, 그때 누적된 시간을 출력하면 된다.

## 🙂 마무리
예전에 풀었던 문제인데 구현에서 막혀서 예전 소스코드를 참고해서 풀었다. `bfs()` 함수 내에서 큐에 넣을 때, BFS 탐색에서 현재 경로가 최소 이동 경로라는 점을 이용하여 "`현재까지 이동한 거리 + 1` 을 해도 지금까지 구한 최솟값보다 작은 경로"만 큐에 삽입하는 것이 불필요한 연산을 막기 위한 포인트.
