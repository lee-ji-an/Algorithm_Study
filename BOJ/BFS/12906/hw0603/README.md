## Info
[12906 새로운 하노이 탑](https://www.acmicpc.net/problem/12906)

## 💡 풀이 방법 요약
각 시점에서 A, B, C 기둥에 존재하는 원판의 정보를 BFS 노드 하나에 담고, pop 할 때 마다  
1. A에서 B, C로
2. B에서 A, C로
3. C에서 A, B로  
  
원판을 이동하는 경우의 수 중 아직 확인하지 않은(방문하지 않은) 노드들을 큐에 추가해 주며 종료 상태가 될 때 까지 반복 하고 종료 상태가 됐다면 그떄까지 움직인 횟수를 출력하면 된다.  
  
사실 풀이법을 생각해내는 것 보다 구현이 조금 까다로운 문제 같은데, "BFS 노드"에 대한 정보를 어떤 구조로 저장하고 연산할 것인지 생각이 좀 필요했다. 제한시간이 5초인 것을 보니 시간이 매우 오래 걸릴 것 같아서 비트마스킹 기법으로 노드 정보를 저장했다.
  
기본적으로 노드 하나는 `(int, int, int)` 형태의 튜플이고, 각 인덱스별로 A기둥, B기둥, C기둥에 놓인 원판의 정보를 의미한다.  
그렇다면 정수 하나만으로 기둥 하나에 놓인 원판의 종류와 순서를 모두 표현할 수 있어야 하는데, 원판의 종류가 3가지이므로 원판 하나를 표현하기 위해 2비트를 사용한다.  
```
원판 A: 0b01
원판 B: 0b10
원판 C: 0b11
````
위쪽에 쌓인 원판일수록 MSB에 가깝게 할당하여 위에서부터 순서대로 BCBA가 쌓인 경우 비트열은 `0b10111001`이 될 것이다.  
이러한 사항들을 고려하여, 비트열을 전달받고 top을 pop 한 값과 pop후의 비트열을 반환하는 `비트를쪼개()` 함수와 현재의 비트열과 top에 삽입할 원판 정보 비트열을 전달받고 삽입 후의 비트열을 반환하는 `맨앞에넣어()` 함수 두 개를 정의하여 BFS 함수 안에서 활용하였다.

## 🙂 마무리
응용 비트마스킹은 언제나 어렵다.. push와 pop 연산을 지원하는 함수를 구현할 때, 원판 A를 `0b01`로 정의했더니 top에 원판 A가 오는 경우 `0b01xxxx` 형태가 되어 `0b1xxxx`로 저장되기 때문에(MSB가 0이므로), 자릿수를 맞추는데 애를 좀 먹었다.  
그래도 비트마스킹으로 풀이한 사람이 없는 것인지 900ms 초반으로 Python3 1등!
