## Info
[6087 레이저 통신](https://www.acmicpc.net/problem/6087)

## 💡 풀이 방법 요약
`C`의 위치 중 한 곳을 시작 지점, 다른 한 곳을 도착 지점으로 설정한다.  
`visited` 배열의 의미를 그 좌표에 도착하기 위한 경로를 구성할 때 필요한 선분 개수(=`필요한 거울 개수+1`)로 정의하고, 최솟값을 업데이트해 나갈 것이므로 초기값은 무한대로 초기화한다.  
  
시작 지점에서 4방향 탐색을 하는데, 이때 한 번 방향을 정했으면 레이저가 직진하는 것 처럼 그 방향으로 최대한 갈 수 있는 좌표(벽에 닿거나 `board` 범위 밖을 벗어나지 않는 한)까지 방문하고 큐에 삽입한다. 다음부터는 큐에서 한 노드씩 꺼내며 다시 그 노드에서 4방향으로 직진할 수 있는 곳 까지 다 방문후 큐에 삽입하는 과정을 계속 반복하면 된다.  
  
이때, 특정 좌표를 방문한 적이 없거나 새로 방문했을 때 사용하는 거울 개수를 줄일 수 있을 때만 그 좌표를 방문하고, 아니라면 더 이상 진행하지 않는다.

## 🙂 마무리
일반적인 BFS 문제와 조금 다른 유형의 문제인 것 같다. 처음에는 다른 문제와 유사하게 인접한 칸을 순서대로 큐에 삽입하며 벽 부수고 이동하기 문제처럼 `visited` 배열에 해당 노드에 도달하기까지 방향 전환 횟수의 최솟값을 유지하는 방향으로 풀이하려고 했는데, 빛의 직진성을 고려하여 유사하게 시뮬레이션하면 보다 쉽게 풀 수 있었다.

## 230205 수정
경로를 만들 수 있는 선분의 최솟값이 줄거나 같은 칸만 방문하면서, 별도의 중복 방문 처리를 하지 않는 코드들에 대한 반례 케이스가 추가되어 코드를 업데이트했다.  
반례는 아래와 같으며, 선분의 개수라는 의미를 가지는 `visited` 리스트 이외에, 내가 `push`하려는 노드가 이전에 `push` 된 적이 있는지를 판단하기 위한 `have_been_pushed`라는 `set`을 별도로 두어 큐 삽입 직후에 순서쌍을 추가해 주고, 순서쌍이 없을 때만 새로 삽입하는 로직을 추가하여 해결하였다.

```
input:
100 7
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
C*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
**************************************************************************************************.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*
C*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*.*
...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*...*

output:
196
```