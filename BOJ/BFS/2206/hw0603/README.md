## Info
[2206 벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)

## 💡 풀이 방법 요약
일반적인 BFS 탐색과 같이 진행하는데, 큐에 넣을 데이터에 현재 벽을 추가로 부술 수 있는 상태의 여부(`breakable`)을 같이 넣어 준다.  
평소대로라면 벽을 만났을 때 그냥 건너뛰겠지만, 이 문제에서는 큐에서 꺼낸 좌표가 `breakable`하다면, 4방향 탐색 할 때 벽이 있는 위치라도 큐에 추가해 주어야 한다.(물론 이 때 부터는 `breakable` 값을 `False`로 지정해 주어야 함)  
  
처음에 틀렸던 부분인데, 방문 처리에도 조금 차이가 생긴다. 특정 좌표를 이미 과거에 방문한 적이 있더라도, 만약 그것이 벽을 부수고 방문한 것이라면 벽을 부수지 않고 방문할 수 있는 경우가 있을 때는 다시 방문하여 그 경우를 조사해 봐야 한다.  
극단적인 예시로 목적지 좌표를 벽이 둘러싸고 있는 경우라면 목적지까지 가는 중간에 경로를 단축시키기 위해 벽을 부수는 선택을 했다면 분명 벽을 피해 우회하여 맨 마지막 목적지 직전의 벽을 부수는 선택을 하면 목적지에 도달할 수 있음에도 불구하고 `breakable`이 `False`인 상태로 그 벽에 도달하여 목적지에 도달할 수 없다고 판단할 여지가 있기 때문이다.  
이를 처리하기 위해 `visited` 배열에 단순 방문 여부를 저장하지 않고
> 0: 방문안함, 1: 벽을 부수지 않은 상태로 방문됨, 2: 벽을 이미 부순 상태로 방문됨

과 같이 상태를 구분하여 저장해 주고, 방문 검사 시 조건을 **해당 위치를 방문한 적이 없거나, 아직 벽을 부술 수 있는데 과거에 벽을 부순 상태로만 방문했을 경우** 로 설정해 주었다.

## 🙂 마무리
Python3 1등이 1600ms가 넘는 걸로 봐서 원래 오래 걸리는 문제인 것을 감안하더라도 실행시간이 너무 오래 걸린다(4840ms). 접근방법이 아예 다른 풀이법이 있는 것일까?
