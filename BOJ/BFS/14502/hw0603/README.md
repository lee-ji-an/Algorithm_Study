## Info
[14502 연구소](https://www.acmicpc.net/problem/14502)

## 💡 풀이 방법 요약
연구실 정보를 입력받으면서 바이러스들의 좌표와 빈 공간의 좌표를 따로 리스트에 저장해 둔다.  
`itertools.combinations` 모듈을 이용하여 빈 공간들 중 3개를 고를 수 있는 모든 경우의 수(nC3)에 대하여 모두 벽을 배치한 후 바이러스를 퍼트려 보고, 각 경우마다 안전 구역의 개수를 구하여 최댓값을 출력한다.  
바이러스 감염은 BFS를 통하여 수행하고, 미리 저장해 뒀던 바이러스의 좌표를 큐에 넣은 상태로 BFS를 수행하여 바이러스가 도달할 수 있는 곳은 모두 바이러스로 채우면 된다.

## 🙂 마무리
`spread()` 함수 호출 시 함수 내부에서 원본 연구실 정보를 수정하면 안 되므로 배열을 깊은 복사해서 넣어야 하는데, `copy.deepcopy()`를 사용하는 것 보다 `[row[:] for row in lab]`을 사용하는 것이 2배 이상 빨랐다.  
  -> list slicing을 통한 방법은 얕은 복사이기 때문. 얕은 복사지만 리스트 원소가 immutable(`int`)객체이기 때문에, 값이 변경되면 객체가 새로 할당된다.

조금 더 개선의 여지가 있을까 하여 아예 호출 전 배열 복사를 없애고, 각 테스트 케이스에서 세운 벽들과 바이러스의 좌표 정보를 저장해 두었다가 원상복구시키는 방법으로 접근했는데 `deepcopy()` 보다는 빨랐지만 list comprehension을 사용한 방법보다는 느렸다. 이유가 뭘까..
