## Info
[4991 로봇 청소기](https://www.acmicpc.net/problem/4991)

## 💡 풀이 방법 요약
브루트포스(순열)의 개념으로 접근하여, 시작 지점부터 BFS탐색을 진행하다가 모든 더러운 칸이 청소되는 시점에 그때의 이동 횟수를 반환하는 방법을 사용한다.  
지나왔던 칸의 재 방문이 가능하므로, 방문 처리 기준을 조금 특별하게 잡아 주어야 하는데, "**특정 BFS 경로에서 동일한 상태(청소한 더러운 칸들의 집합)를 가지고 같은 칸을 재 방문 할 필요가 없다**"는 것에 집중한다.  
>더러운 칸의 "순서"가 아닌 "집합"만 고려해도 되는 이유는, `1->2->3`순으로 청소한 노드가 방문 마킹되었다면, `2->1->3` 혹은 `3->2->1` 등의 그 뒤에 큐에서 pop된 노드들은 항상 첫 방문보다 `dist`가 클 것이기 때문이다.  

테스트 케이스 하나를 처리할 `bfs(robotPos, sortedTrash)` 를 정의한다. 이 함수는 초기의 로봇 위치와 오름차순 정렬된 더러운 칸의 좌표 리스트를 전달받고, 모든 칸을 청소하기 위한 최소 이동 횟수를 반환하는 함수이다.  
  
함수 내에서는 방문 처리를 위해 visited 배열을 맵 크기와 같은 2차원 배열로 선언해 주고, 배열의 원소로 빈 집합(`set()`)을 할당한다. 이 집합들은 `(row, col)`에 도착했을 때, 각 경로에서 청소한 더러운 칸의 index 정보가 담긴 비트열이 저장되는 집합이 된다.  
청소한 더러운 칸의 집합 정보를 저장하기 위해 비트마스킹을 사용한다. 더러운 칸은 최대 10개이므로 [0~1024) 구간의 정수로 모든 경우를 다 표현할 수 있을 것이다. 4방향 탐색을 진행하며 현재 비트열을 가지고 방문하지 않은 빈 칸을 만났을 경우 `clean_bit`는 변경하지 않고 좌표만 업데이트하여 큐에 삽입하고, 방문하지 않은 더러운 칸을 만났을 경우, 그 좌표와 함께 현재의 `clean_bit`와 `sortedTrash`에서 현재 만난 더러운 칸 좌표 튜플의 인덱스만큼 `1`을 bit shifting 하여 OR 연산해 준 값을 큐에 삽입한다.  
`sortedTrash` 배열은 정렬된 배열이므로, 이진탐색을 활용하여 `next_bit = clean_bit | (1 << bisect_left(sortedTrash, (nrow, ncol)))` 형태로 비트열을 만들면 인덱스를 빠르게 찾을 수 있다.  
  
`dist`는 다른 문제와 유사하게 매 반복마다 큐의 길이를 체크하여 큐 길이만큼의 pop연산이 진행되었다면 `dist`를 1 증가하면 되고, 청소가 모두 끝난 상태의 판단을 위해서는 `(1 << len(trash)) - 1` 로 더러운 칸 개수만큼 bit ON 된 비트열과 현재 노드의 비트열이 동일한지 여부를 활용할 수 있다.


## 🙂 마무리
처음에 순열 브루트포스(10! == 약 400만)를 그대로 사용했다가는 당연히 시간 초과가 날 것 같아서 아기 상어 문제와 비슷한 방향으로 매 함수 호출 마다 현재 위치에서 가장 최적의(=가까운) 더러운 칸을 청소하고, 로봇 청소기의 좌표를 계속 이동시키는 방향으로 접근했는데, 논리에 오류가 있음을 꽤 오랜 시간이 지난 후에야 알게 되었다.  
그리디 방식의 반례는 다음과 같다.  
![image](https://user-images.githubusercontent.com/31981462/215369522-e1b89332-d8b9-4bd1-9a3c-40469512bdc9.png)
