## Info
[4991 로봇 청소기](https://www.acmicpc.net/problem/4991)

## 💡 풀이 방법 요약
### BFS + 순열을 이용한 풀이
> 청소해야 할 칸들의 방문 순서를 미리 정해놓고 거리 정보를 더한다
- 각 점당 1번의 BFS를 수행하여 다른 모든 점들까지의 거리를 구하여 인접 행렬을 미리 만든다
- 시작 위치에서부터 각 더러운 칸들의 방문 순서를 순열을 이용해서 구한다
- 인접 행렬의 거리 정보를 보고 더해가면서 이번 시행의 경로 거리를 구하고 최솟값을 찾는다

### TSP 알고리즘을 이용한 풀이
> 다음 방문하지 않은 칸을 방문했다고 가정하고 최솟값을 계속해서 찾아나가는 TSP 알고리즘
- 각 점당 1번의 BFS를 수행하여 다른 모든 점들까지의 거리를 구하여 인접 행렬을 미리 만든다
- 시작 위치에서 시작하여 비트 마스킹을 통해 각 점에 방문 유무를 기록하고, 방문하지 않은 다음 점을 찾는다
- 방문하지 않은 점에 대하여 그 점을 방문했다고 처리한 상태로 재귀적으로 `DFS` 함수를 한번 더 호출, 결론적으로 최소 경로를 찾을 수 있음

## 🙂 마무리
TSP 알고리즘이 생각나긴 했는데 DP와 관련된 알고리즘이라 생각해서 다른 방법을 찾아 브루트 포스로 해결하였다가 python3으로는 시간 초과가 발생했다.