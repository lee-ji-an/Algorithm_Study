## Info
[16933 벽 부수고 이동하기 3](https://www.acmicpc.net/problem/16933)

## 💡 풀이 방법 요약
다른 벽 부수고 이동하기 시리즈 문제들과 유사한 방법으로 풀이하되, 이 문제에서는 낮과 밤이 추가되어 낮에만 벽을 부술 수 있으므로 `cnt % 2`를 체크하여 현재 상태가 낮인지 밤인지를 판단한다.  
만약 벽을 부수고 앞으로 가야 하는 경우라면 다음과 같이 분기하여 처리한다.
1. 현재 상태가 낮이라면, 그냥 부수고 들어간다.
   - `q.append((n_row, n_col, cnt+1, broken_walls+1))`
2. 현재 상태가 밤이라면, 새로운 좌표로 이동하지 않고 대기(cnt만 증가)한다.
   - `q.append((row, col, cnt+1, broken_walls))`

주의할 것은 방문 처리는 **(1)낮에 실제로 벽을 부수고 간 경우**에만 해 주어야 한다는 것이다.  
또한, BFS가 특정 목적지까지 도달하기 위한 최소 이동 횟수를 보장하는 이유는 **현재 노드의 인접 노드들을 방문하며 순서대로 큐에 삽입되기 때문**이다. 따라서 N번째 이동 후 현재 상태가 "밤"이라서 한 턴을 쉬어야 될 때, 단순히 **`cnt+2`와 다음 좌표**를 큐에 삽입하는 것이 아니라 **`cnt+1`과 현재 좌표**를 삽입하여 실제로 한 턴을 기다려 줘야 한다. `cnt+2`를 바로 삽입할 경우 큐에 삽입된 노드들의 `cnt` 대소 관계가 어긋나게 되어 처음으로 목적지에 도달했을 때, 그 때의 `cnt`값이 최소인지 보장받을 수 없게 된다.


## 🙂 마무리
초기 코드에 방문 조건을 잘못 체크(밤인데도 방문처리를 함..)하거나 밤에 `cnt+2`와 다음 좌표가 포함된 노드 정보를 큐에 삽입하는 등의 자잘한 논리적 오류가 있었고 이것을 알아차리는데 아주 많은 시간을 썼다. 차근차근 조건을 체크하자..
  
처음에는 `cnt` 정보도 노드에 포함하여 큐에 같이 삽입했었는데, 맞춘 후 리팩토링 과정에서 굳이 큐에 삽입할 필요 없이 전역변수로 두고 한 회차 이동이 끝날 때 마다 1씩 증가시키는 방법을 사용해도 될 것 같다는 생각을 했다.  
결과적으로는 `while(q)` 이후 바로 원소를 pop하지 않고, while문이 한 번 돌 때 마다 그때의 큐 길이를 체크하고, pop 로직을 그 길이만큼만 반복하는 반복문으로 감싸 주면, 그 루프 안에서는 각 `cnt`에서 새로 삽입된 노드들만 조사하겠다는 의미가 되므로, 추가한 루프 종료 이후 while 조건 검사 이전에 `cnt+=1`을 해 주는 방식으로 해결했다.  
pop 전에 큐 길이를 체크하는 방법은 거의 사용해 보지 않았는데, 알아 두면 쓸 일이 있을 것 같다.
  
홀수/짝수 체크 시 `num % 2` 보다 `num & 1` 이 더 빠르다! 다만 직관적인 것은 전자이므로 시간 단축이 꼭 필요하고 홀짝 체크가 빈번하게 일어날 때만 사용하는 것이 좋을 듯