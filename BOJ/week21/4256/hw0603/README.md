## Info
[4256 트리](https://www.acmicpc.net/problem/4256)

## 💡 풀이 방법 요약
1. 전위순회의 첫 번째 값은 루트노드이다.
2. 중위순회에서 루트노드의 위치보다 앞에 있는 것들은 leftChild, 뒤에 있는 것들은 RightChild 이다.

이 두 가지 사실을 이용하여 풀이한다.
최상위 루트의 leftChild와 RightChild (서브트리들) 에 대해 1, 2번 과정을 재귀적으로 반복하고, 루트노드를 마지막에 출력시키면 된다.
  
예를 들어,
```
[3] 6 5 4 8 7 1 2 의 전위순회 결과가 주어졌을 때,
5 6 8 4 [3] 1 2 7 이 중위순회 결과라면
왼쪽 서브트리의 원소는 {5, 6, 8, 4}이고 오른쪽 서브트리는 {1, 2, 7}임을 알 수 있다.

후위순회에서 루트노트는 가장 마지막에 출력되므로 [3]을 맨 끝에 출력하도록 처리하고
왼쪽 서브트리의 전위/중위 순회인 [6, 5, 4, 8], [5, 6, 8, 4] 를 기준으로 로직을 반복한다.
완료되면 [7, 1, 2], [1, 2, 7] 에 대해서도 로직을 수행해 주고..
~~
위와 같이 재귀적인 처리를 통해 후위순회 결과를 구할 수 있다.
```


## 🙂 마무리
신박한 문제였다. 처음에는 원본 트리를 구할 수 있을 것 같아서 원본 트리를 구축해 놓은 다음에 후위순회 탐색을 진행하려고 했는데 한 번에 처리가 가능했다.
리스트 슬라이싱으로 넘겨서 시간이 좀 오래 걸린 것 같은데, 인덱스를 기준으로 처리하면 훨씬 빨라지긴 할 듯
