## Info
[4195 친구 네트워크](https://www.acmicpc.net/problem/4195)

## 💡 풀이 방법 요약
> union-find

* 문자열이라 root 배열 대신 map으로 해봤습니다.
* map 하나 더 사용해서 해당 root 아래 원소 개수를 저장했습니다.
* 친구 관계가 생길 때마다 union하고, 둘 중 한 명의 root에 달린 친구 수를 출력했습니다.
* f1의 root를 f2로 갈아줄 때, f1 아래 원소 개수를 f2 아래 원소 개수에 더해주고 f1 아래 원소 개수는 0으로 초기화했습니다.
* union할 때 둘의 root가 같으면 하지 말아야 합니다. 0으로 초기화될 수도 있기 때문이죠
* 근데 어차피 트리 길이 세었으니 union 최적화까지 할 수 있었겠습니다.
* 그럼에도 불구하고 find 최적화까지만 해봤습니다.
* 그래서 느렸습니다.

## 🙂 마무리
