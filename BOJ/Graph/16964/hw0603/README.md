## Info
[16964 DFS 스페셜 저지](https://www.acmicpc.net/problem/16964)

## 💡 풀이 방법 요약
입력받은 경로를 덱에 넣고 DFS를 실제로 수행하면서 지점을 방문할 때 마다 덱을 `popleft()` 하며 다음 경로가 방문 가능한지(현재 노드와 인접한지) 확인한다. 이때 `in` 연산을 빠르게 하기 위해 인접리스트를 `set` 으로 유지한다.  
  
보통
```
for adjNode in graph[currentNode]:
    ...
```
위와 같이 현재 노드의 인접리스트를 순회하며 dfs를 호출하므로, 인접리스트에 저장된 노드들의 순서가 방문 순서가 되는데, 이 문제에서는 입력으로 제공받은 경로를 우선적으로 방문해 보도록 처리하는 것이 중요하다.
  
경로에 맞게 방문을 시도하고 난 후, 덱이 노드가 남아있다면 그 노드는 방문하지 못한 것이므로 잘못된 경로이고, 덱이 비어있다면 올바른 경로이다.

## 🙂 마무리
노드는 1부터 시작한다는 조건을 제대로 못 읽어서 첫 제출때 100%에서 틀렸습니다가 떴다.  
dfs에서 방문 순서를 내가 직접 지정하는 문제는 처음 풀어본 것 같은데 조금 더 깔끔한 방법이 없을까?
