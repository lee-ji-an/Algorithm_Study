## Info
[19236 청소년 상어](https://www.acmicpc.net/problem/19236)

## 💡 풀이 방법 요약
DFS로 풀이한다. `dfs()`의 반환값은 그 시행에서 상어가 먹은 물고기 번호의 최대 합이다.  
  
1. `space`안에서 물고기의 번호와 방향을 저장한다. 잡아먹힌 물고기는 번호를 `0`으로 마킹한다.
2. DFS 탐색을 진행하면서 상어가 그 방향으로 움직였을 때 먹은 물고기의 번호를 `score`에 누적해 준다.
3. 상어가 물고기를 먹은 후 다시 물고기의 이동이 발생한다. `space`에서 어떤 물고기의 번호가 존재한다면 먹히지 않은 것이다.
   1. 해당 물고기의 방향대로 이동할 수 있다면 이동하는 곳의 위치와 현재 위치의 `space` 정보를 swap.
   2. 해당 물고기의 방향대로 이동할 수 없다면 이동할 수 있는 곳을 찾을 때 까지 반시계 방향 45도로 회전한다.
4. 물고기가 모두 이동한 후, 상어의 이동이 시작된다. 4x4 공간이므로 상어는 자신의 방향으로 최대 3칸까지 이동할 수 있다. 즉, 현재 노드에서 자식노드의 개수는 최대 3개이다. 이 자식노드들에 대해 dfs 탐색을 진행해 주고, 각 노드 중 반환값이 가장 큰 것을 취해서 리턴하면 된다.

## 🙂 마무리
처음에 계속 답이 틀려서 뭔가 했는데 물고기 데이터를 입력받을 때 `dr`, `dc` 인덱스를 잘못 맞춰준 오류였다.  
공간 크기가 4x4라서 물고기 번호에 맞는 좌표를 전체탐색으로 찾아도 큰 문제가 없는 것 같다. `fishIdx2pos` 같은 딕셔너리에 물고기 인덱스 별 좌표를 계속 유지하는 방식으로 빠르게 찾으면 더 빨리 풀 수 있을 것 같은데 구현하다 보니 처리해야 할 것들이 꽤 많아져서 끝까지 구현해보지는 않았다.
예전에 풀었을 때와 달리, 재귀함수의 반환값을 활용해 보았다.
