## Info
[1509 팰린드롬 분할](https://www.acmicpc.net/problem/1509)

## 💡 풀이 방법 요약
특정 구간이 팰린드롬을 만족하는지 여부를 찾기 위해 1번, 최소 분할 수를 구하기 위해 1번, 총 2번 DP를 사용하는 문제이다.  
  
### 특정 구간이 팰린드롬을 만족하는가?
우선 길이가 `1`인 팰린드롬과 길이가 `2`인 팰린드롬에 대하여 `True`를 마킹해 둔다.  
길이가 `3~L`인 팰린드롬에 대해서 DP를 적용하는데, 처음과 끝이 동일한 문자이고, 그 사이가 팰린드롬이라면 전체 문자열이 팰린드롬이라는 원리를 사용하여 `isPalindrome[i][j]`에 대한 전체 데이터를 구해 둔다.
  
### 최소 분할의 개수는 몇 개인가?
위에서 얻은 정보를 통해 특정 구간이 팰린드롬을 만족하는지에 대한 정보를 `O(1)` 만에 찾을 수 있게 되었다.  
`dp[i] = i번째 문자까지 조사했을 때, 팰린드롬 분할의 최소 개수`로 정의하자.  
만약 `start ~ end` 가 팰린드롬을 만족한다면, `dp[end]` 값은 `start` 바로 앞 까지의 dp값 + 1(이번 팰린드롬 덩어리)이 될 것이고, 팰린드롬을 만족하지 않는다면 단순히 `S[end]`문자 하나만으로 분할해야 하므로 `dp[end-1] + 1` 이 될 것이다.
  
따라서, 다음과 같은 기본 로직을 통해 dp 테이블을 채워 나가고, `dp[-1]`을 출력하면 정답
```python
for end in range(L):
    for start in range(1, end+1):
        dp[end] = min(
            dp[end],
            dp[start-1]+1 if isPalindrome[start][end] else dp[end-1]+1
        )
```


## 🙂 마무리
사실 위의 코드만으로는 dp리스트 길이를 정확히 `L`로 선언했을 때 문제가 생긴다.  
처음에 실수했던 부분인데, `dp = [sys.maxsize for _ in range(L)]` 와 같이 선언해 두고 위 로직을 통해 풀이하면 start가 `0`일 때 `min` 함수에서 `dp[0-1]`을 참조하게 되어 논리적으로 전혀 관련이 없는 dp 테이블의 가장 마지막 원소와 대소피교를 진행하게 된다. 따라서 다음과 같이 `0~end`가 팰린드롬 그 자체일 때는 `dp[end]`를 `1`로 미리 확정짓고, `start`를 루핑할 때는 1부터 시작하게 변경하여 풀이했다.
```python
for end in range(L):
    # 0~end가 이미 팰린드롬이면 더 볼 필요도 없이 1로 확정
    if (isPalindrome[0][end]):
        dp[end] = 1
        continue

    for start in range(1, end+1):
        ...
```
  
한 이틀 고민하다가 답이 안 보여서 검색해서 풀었다. 2차원 배열로 특정 구간이 팰린드롬을 만족하는지 미리 구해두는 것은 팰린드롬 문제에서 거의 탬플릿이라고 할 수 있을 것 같은데, 익숙하지 않아서 그런지 '2차원dp로 구해야 하나?' 라고 생각만 하고 확신이 없어서 그 뒤의 풀이(분할 DP)를 더 떠올리지 못했다. 이제 안 까먹겠지.