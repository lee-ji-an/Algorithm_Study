## Info
[1562 계단 수](https://www.acmicpc.net/problem/1562)

## 💡 풀이 방법 요약
기본적인 아이디어는 맨 끝 숫자를 알면 그 다음에 올 숫자를 알 수 있다는 것.  
0부터 9까지 모든 숫자가 나와야 한다는 조건이 있으므로 비트마스크(`2^10`)를 사용하여 1024가지의 모든 경우에 대해 계산을 해 두고, 모든 계산이 끝난 뒤 비트가 모두 켜진(1023) 것만 개수를 세어 주는 것!

---

DP + 비트마스크를 활용하여 풀이한다.  
`dp[lastnum][bitmask]` 로 정의하고, `bitmask`는 10비트의 정수로, `0~9`의 숫자가 각각 사용되었는지 여부를 나타낸다.  
  
그 다음은 이전 DP값(`dp[N-1]`)에서 현재 DP값(`DP[N]`)을 구하는데, dp배열 전체를 순회하며 현재 조사중인 `lastnum`을 추가해 준다.  
이때, `lastnum=0` 인 경우와 `lastnum=9` 인 경우는 각각 `1`과 `8`만 추가할 수 있으므로, 분기하여 처리해 준다.  
  
DP 배열은 항상 바로 직전의 값만 참조하므로, [10844 쉬운 계단 수](https://www.acmicpc.net/problem/10844)에서 풀이했던 것 처럼, DP배열을 여러 행이 아닌 두 행만을 선언하여 덮어쓰는 형태로 접근해도 된다.  
  
계산이 끝난 후 lastnum=0~9 에 대해 비트가 모두 켜진 경우(`0b_0011_1111_1111`)의 개수를 합산하여 출력하면 정답.

## 🙂 마무리
한참을 고민했는데 생각이 떠오르지 않아 결국 풀이를 참고했다. 어떤 느낌으로 돌아가는지는 알겠는데 마음으로 와닿지 않는다..
