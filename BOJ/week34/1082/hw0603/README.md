## Info
[1082 방 번호](https://www.acmicpc.net/problem/1082)

## 💡 풀이 방법 요약
정답의 자릿수를 먼저 확정지어 두고, 확정지은 자릿수의 앞부터 차례로 순회하며 남은 예산 안에서 최대한 큰 수를 구매하는 방식으로 풀이한다.  
  
1. 첫 자리에 올 수 있는 0이 아닌 가장 저렴한 숫자를 구한다.
2. 첫 자리 수를 구하고 남은 돈으로 가장 저렴한 숫자를 최대 몇 개 살 수 있는지 구한다.
3. 첫 자리 수 + 남는 돈 다 털어서 산 가장 저렴한 숫자 concat 하면 정답의 자릿수를 확정지을 수 있다.
4. 자릿수 확정된 `result` 리스트를 앞에서 부터 순회하면서 남은 예산 안에서 숫자 교체

## 🙂 마무리
코드에서는 `bisect`를 사용했는데, 이미 정렬한 상태의 데이터를 순회하므로 굳이 `bisect`까지 쓸 필요가 없을 것 같다.  
사실 처음에는 `(price, num)` 형태의 데이터가 담긴 리스트를 정렬한 후, bisect 탐색하여 그 결과를 그대로 사용하면 된다고 생각해서 이진탐색을 적용했었다. 하지만 각 루프의 `budget` 을 최대한 사용한다고 해서 당연히 숫자까지 최대가 되지 않기 때문에 모든 경우를 탐색하여 최댓값을 찾아 줘야 한다.  
ex) 예산이 8원 남았을 때 (4원, '9')를 사는 것이 (8원, '7')을 사는 것 보다 이득이다.
  
여담이지만, bisect 결과를 그대로 구매해도 81%까지 진행된 이후에야 "틀렸습니다"가 떠서... 로직 자체의 문제가 아닌 엣지 케이스가 있다고 생각하여 로직 수정이 좀 오래 걸렸다..
