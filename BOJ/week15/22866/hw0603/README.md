## Info
[22866 탑 보기](https://www.acmicpc.net/problem/22866)

## 💡 풀이 방법 요약
![image](https://user-images.githubusercontent.com/31981462/230622400-4c869a23-1d5e-4bd0-83ff-ef6fa59215b5.png)
스택을 사용하여 풀이한다.  
왼쪽에서 오른쪽으로 탐색하며 `stack`에는 각 탑의 인덱스를 저장하게 되는데, 각 탑을 조사할 때 마다 해당 탑보다 높이가 낮거나 같은(그 탑에서 볼 수 없는) 탑들은 모두 `pop()` 해 준다.  
> 어차피 지금 조사하고 있는 탑이 존재하는 이상, 자신보다 오른쪽에 있는 탑들은 자신이 볼 수 없는 탑은 마찬가지로 볼 수 없기 때문  
  
`pop()` 과정을 마치게 되면, 그 당시 스택에 남아있는 원소의 개수가 바로 내가 지금 조사하고 있는 탑에서 볼 수 있는 탑들의 개수이므로 `visible_cnt[i]`에 누적해 준다.  
최근접 탑을 구하기 위해서 `nearest[i]`와 `i`의 거리, `stack[-1] (stack top)`과 `i`의 거리를 비교하고, 현재 스택의 `top`에 있는 탑과의 거리가 더 작다면 갱신한다.  
  
이 과정을 동일하게 오른쪽에서 왼쪽으로 방향을 바꾸어 진행한 다음, 결과를 출력하면 정답.


## 🙂 마무리
스택 활용하는 문제에 익숙하지 않다... "같은 수로 만들기" 문제와 유사하다고 생각은 했었는데 그 문제는 스택으로 안 풀었어서 `O(N^2)` 풀이밖에 생각이 안 나서 구글링했다.  
설명을 보고 구현한 후에, `L->R 후 R->L` 하는 것과, `R->L 후 L->R` 하는 것이 동일할 것이라고 생각해서 `iterator` 변수를 설정하는 outer loop에서 `set`으로 선언했는데, 자꾸 랜덤한 퍼센트에서 "틀렸습니다"가 떴다.  
알고 보니 `L->R 후 R->L` 순서대로 계산해야만 정답이 나오는데 왜지..?
