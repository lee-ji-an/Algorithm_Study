## Info
[16929 Two Dots](https://www.acmicpc.net/problem/16929)

## 💡 풀이 방법 요약
DFS를 활용하여 사이클이 생성되는지 검증한다. `dfs()` 함수의 인자로 방문할 좌표의 위치와 최초 시작 좌표의 위치, `cnt`(호출 depth)를 전달받는다.  

`dfs()` 내부에서는 상하좌우 4방향의 인접한 좌표에 대해 방문 여부, 사이클 생성 여부(초기좌표랑 동일한 좌표), `board` 범위 벗어남 여부를 확인하여 전진할 수 있다면 재귀호출하고, 사이클을 생성할 수 있다면 전역변수 `ans`를 `True`로 설정하고 리턴한다. 재귀호출 전에는 해당 좌표를 방문처리하고, 다음 방향의 호출에서는 그 좌표가 영향을 받으면 안 되므로 한 번 재귀호출이 끝나면 다시 그 좌표를 미 방문 처리해 주어야 한다.  
  
**또한, 함수가 호출되었을 때 전역변수 `ans`가 `True`인지를 체크하여 `True`라면 다른 경로의 재귀호출에서 이미 사이클을 찾았다는 의미이므로 바로 리턴해 주어야 한다!**

## 🙂 마무리
1. `dfs()` 호출 초기에 사이클 발견 여부를 체크하여 찾았다면 바로 반환
2. 재귀호출 전후로 방문처리/방문처리 해제

이 두 가지가 핵심 포인트인것 같다. 특히 2번의 경우, 각 콜스택마다 4방향으로 총 4번의 재귀호출이 일어나는데, 자신보다 먼저 호출된 함수가 경로를 찾았다면 플래그 변수의 형태로 나머지 함수들을 중지시키는 작업이 필요하다. 처음에 이거 생각 못 해서 TLE 떴음..  
1번을 처리하고 난 이후에 시간 초과는 면했지만 매 호출마다 `hist`라는 집합을 계속 유지하고 있었기에 매우 느렸다(약 1900ms). 하지만 이를 단순 `visited` 배열로 처리하여 실행시간을 대폭 줄일 수 있었다(약 56ms).
