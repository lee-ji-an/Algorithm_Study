# 문제 링크
[링크](https://www.acmicpc.net/problem/2529)

# 풀이 방법 요약
> 조건을 활용한 백트래킹을 사용해서 재귀의 depth를 하나씩 늘려가는 방식으로 해결했다.

`chosen` 이라는 배열에 넣을 때 다음과 같은 조건을 사용한다.
- 첫 번째 자리일 때
- 마지막 원소(`chosen[-1]`)보다 작고, 부등호가 `>` 일 때
- 마지막 원소(`chosen[-1]`)보다 크고, 부등호가 `<` 일 때

한 번 사용된 숫자가 중복 사용되면 안되므로 사용한 여부를 체크해주기 위한 `used` 배열에 넣는 숫자 i의 체크 여부를 1로 하여
재귀적으로 함수를 실행시키고, 백트래킹을 위해 다시 0으로 만들어 준다.

입력한 부등호의 개수가 n개라면, `chosen`에 들어갈 수 있는 원소 수는 n+1개이고 이 때 재귀의 깊이, 즉 `chosen`에 들어가 있는 원소 수를 기록하는 `depth` 변수를 사용한다.

`depth`가 n+1이라면 일단 부등호 조건을 만족하는 수 배열이 만들어졌고, 최솟값, 최댓값 정보를 확인, 갱신한다.

# 느낀 점
전체 순열을 다 만들고 부등호를 사이사이 끼워보는 방법을 생각했었는데 너무 경우의 수가 많고, 전체 순열들 중에서 부등호 조건을 만족하는 순열이 얼마나 될까 싶어서 부등호 조건에 맞는 숫자들을 하나씩 끼워넣자는 생각이 있었다.

중간중간 숫자 배열을 하나의 숫자로 합치는 방법 등 자잘한 파이썬 사용법이 기억이 안나서 애를 먹음...