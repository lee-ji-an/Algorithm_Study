## Info

[2529 부등호](https://www.acmicpc.net/problem/2529)

<br>

## 💡 풀이 방법 요약

> 정렬되어 있는 배열에서 하나씩 꺼내서 순차적으로 대입해보고 부등호에 안 맞으면 밀어서 제자리 찾기 

| i   | 0   | 1   | 2   |
|-----|-----|-----|-----|
| c   |     | <   | \>  |
| max | 9   | 8   | 7   |
| min | 0   | 1   | 2   |

make 함수의 q에 max를 넣어서 최댓값, min을 넣어서 최솟값을 구한다.

###  make 함수
1. arr의 0번째 원소에 q의 0번째 원소를 넣어서 초기화
2. idx는 1로 초기화, 순차적으로 q의 원소 하나씩 꺼내서 사용하기 위함
3. arr[i-1]번째 원소와 q[idx] 비교
   1. c[i]번째 부등호와 대소관계가 일치하면 q에서 하나 꺼내서 arr[i]에 대입
   2. 일치하지 않으면 j = i에서 j--하면서 c[i] == c[j] 인 동안 arr[j-1]을 오른쪽으로 한 칸 밀어주고 생긴 칸에 q에서 꺼내서 대입
4. arr를 String으로 예쁘게 변환해서 반환

### replaceAll
* Arrays.toString(arr)를 하면 [1,2,3] 이런 형태로 되기 때문에 replaceAll을 사용해서 알맞게 변환했다. <br>
* 첫번째 파라미터에 문자열이나 정규식을 넣으면 두번째 파라미터르 바꿔준다.
* 정규식에 사용되는 특수문자(*+|!<>., 등)는 []로 감싸주면 문자 그대로 인식한다.
* 소괄호, 중괄호, 대괄호, ^는 앞에 \\\를 붙여주면 문자 그대로 인식한다.

### IntStream과 Stream
* 순차적으로 정수가 들어간 배열을 멋지게 만들 때 사용하기
* 오름차순 배열 (0~n-1)
  ```java
   int[] arr = IntStream.range(0, n).toArray();
   ```
* 내림차순 배열 (n-1~0)
  ```java
   int[] arr = IntStream.range(0, n).map(i -> n-i-1).toArray();
   ```
    내림차순은 한 번에 할 수 없어서 오름차순 배열을 만들고 그걸 뒤집어야 한다.<br>
    다양하게 시도해봤는데, 이 방법이 가장 간단한 것 같다.

<br>

## 🙂 느낀 점
1. Stream이랑 IntStream 같은걸 유용하게 잘 써보면 아주 예쁜 코드가 될 것 같은데 아직 쉽지가 않다.
2. 내가 먼저 풀고 강의를 봤는데 세상에 너무 다르게 풀길래 일단 풀어주는대로 해봤는데 next_permutation을 안짜고 내 맘대로 순열을 해버려서 그런지 메모리나 시간이나 훨씬 많이 들긴 했다. 대신에 처음 배열을 무조건 0~9로 하는 대신 필요한 것만 만드는 걸로 고쳐봤다. 최백준씨 풀이에 대해 같이 얘기해보면 좋을듯 ^^