## Info

[12100 2048 (Easy)](https://www.acmicpc.net/problem/12100)

<br>

## 💡 풀이 방법 요약

> 각 방향별로 dfs로 5회 밀어서 만들 수 있는 최댓값 구하기

예시) 오른쪽으로 민 경우

| 판    | list | 결과   |
|------|------|------|
| 2024 | 44   | 0044 |

1. 미는 방향의 끝에서부터 반대 방향으로 탐색하면서<br>
   * 같은 숫자가 인접하고 merge가 false면 더해서 리스트에 추가하고 merge를 true <br>
   * 아니면 원래 숫자를 리스트에 추가하기
2. 끝에서부터 숫자 리스트의 숫자 하나씩 넣어주고 숫자 리스트 끝나면 0 넣어주기

<br>

## 🙂 느낀 점
처음에는 switch의 각 case마다 이중 for문으로 일단 짰다. 그러고나서 ArrayList 대신 Deque을 사용하고, 중복 코드를 함수로 빼는 정도 리팩토링을 해봤다.
코드 길이는 거의 반이 되었고 시간과 메모리양도 아주 조금 줄일 수 있었다.
