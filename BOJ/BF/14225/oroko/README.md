## Info

[14225 부분수열의 합](https://www.acmicpc.net/problem/14225)

<br>

## 💡 풀이 방법 요약

> 각 수의 인덱스를 비트로 표현해서 부분집합과 합을 구해서 없는 최솟값 구하기

| 입력      | 인덱스     | 저장               |
|---------|---------|------------------|
| 2 1 2 7 | 0 1 2 3 | 1111(2) = 15(10) |

1. N자리 꽉 찬 집합의 부분집합을 구한다.
2. 각 부분집합의 원소를 인덱스로 가지는 값의 합(부분집합의 합)을 구해서 sums 배열에 마킹한다.
3. 1부터 부분집합의 합의 최댓값까지 순차 탐색하면서 sums 배열에 마킹되어 있지 않은 최솟값을 찾는다.

### 비트마스크로 부분집합 구하기
```java
for(int subset = set; subset > 0; subset = (subset - 1) & set) {
    String aSubset = Integer.toBinaryString(subset);        
}   
```
#### [ 주의 ]
* int는 32bits로 저장되기 때문에 꽉 찬 집합을 구할 때 ~(1 << N)으로 하면 앞에 1이 그만큼 붙어서 나오기 때문에 (1 << N) - 1로 구하자
* 연산자 우선순위는 산술연산자 > 논리연산자 이다.

<br>

## 🙂 느낀 점
&nbsp;우와 나는 비트마스크가 너무 어렵다. 처음에 냅다 각 입력값을 각 자리 비트로 나타냈는데 (예를 들어 1 3 4 이면 1101) 그러면 중복값이 들어오면 처리할 수가 없어서 인덱스를 비트로 나타내는걸로 바꿨다.
생각해내는 데 한참 걸렸네 휴