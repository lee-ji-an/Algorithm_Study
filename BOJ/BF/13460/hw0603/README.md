## Info
<a href="https://www.acmicpc.net/problem/13460">
    13460 구슬 탈출 2
</a>

## 💡 풀이 방법 요약
`board`의 정보를 입력받으면서 빨간 구슬, 파란 구슬, 구멍의 좌표를 별도로 저장해 두고, 실제 `board` 배열에는 벽과 빈 공간, 구멍만 존재하도록 저장한다(두 구슬의 위치도 우선 빈 공간 처리)  
  
문제의 조건에 맞게 현재 각 구슬의 좌표와 기울이는 방향을 전달받아 해당 방향으로 기울였을 때 최종 구슬의 좌표를 반환하는 `tilt()` 함수를 정의한다.  
무한루프 안에서 각 구슬이 벽에 닿거나 구멍에 빠져 더 이상 진행할 수 없을 때 까지 Red와 Blue의 좌표를 전달받은 방향으로 한 칸씩 이동시키며 최종 위치를 구해야 한다.  
  
1. 새로운 구슬의 좌표(한 칸 이동한 좌표)가 벽 위치라면 그 방향과 반대 방향으로 한 칸 이동시켜 이동을 취소하는 효과를 구현한다.
2. 로직 수행 후 빨간 구슬과 파란 구슬의 최종 좌표가 동일한 경우(두 구슬이 겹치는 경우)가 있다면, 적절히 처리해 주어야 한다.
    - 우선 두 구슬의 좌표가 겹쳤다는 것은 해당 방향으로 기울였을 때 더 이상 움직일 수 없는 위치까지 왔다는 것이므로 두 구슬 모두 이동을 중지시킨다.
    - 그 이후 두 구슬 중 하나를 `victim`으로 설정하여 해당 구슬의 이동을 한 단계 실행취소한다.
    - 기울이는 방향을 고려해 보면 다음과 같은 조건이 만들어진다.
      - 상: row가 더 큰 것을 실행취소
      - 하: row가 더 작은 것을 실행취소
      - 좌: col이 더 큰 것을 실행취소
      - 우: col이 더 작은 것을 실행취소
3. 파란 구슬이 구멍에 빠진 경우는 실패임이 자명함으로 센티널 값을 반환하면 되지만, 빨간 구슬이 구멍에 들어갔다고 해서 바로 성공을 판단하면 안 된다. 문제의 조건에서 빨간 구슬과 파란 구슬이 같이 빠져도 실패로 간주한다고 했기 때문.
  
`tilt()` 함수의 정의가 완료됐다면 문제에서 최대 이동 횟수인 10회 이내에서 나올 수 있는 모든 경우를 테스트하면 된다. 중복순열이므로 `PI(4, 10)` 이고, `itertools.product`로 알맞은 `iterator`를 활용할 수 있다.  
루프 안에서 `tilt()`를 호출하여 기울이는 동작을 시뮬레이션하고, 각 호출 결과에 대해 어떤 구슬이 빠졌는지 여부를 체크하여 조건에 맞는 이동의 최소 횟수를 구할 수 있다.  
**이 때, 연속해서 같은 방향으로 기울이는 경우는 의미가 없으므로 제외해 주어야 한다.**

```
for dirlist in product(("상", "하", "좌", "우"), repeat=10):
    # 연속해서 같은 방향으로 기울이는 경우 skip
    if (any(i == j for i, j in zip(dirlist, dirlist[1:]))):
        continue

    # 순서쌍에 맞게 시뮬레이션
    for dir in dirlist:
        r, b = tilt(dir, r, b)

        ... # 어떤 구슬이 빠졌는지 체크
```

## 🙂 마무리
`tilt()` 함수의 조건에 맞게 구현하느라 애를 꽤 먹었다. 함수를 구현하고 나니 단순한 가지치기 후 브루트포스로 쉽게 풀 수 있었다.
