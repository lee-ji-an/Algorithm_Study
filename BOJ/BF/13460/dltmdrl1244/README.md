# 문제 링크
[링크](https://www.acmicpc.net/problem/13460)

# 풀이 방법 요약
> BFS를 사용하되 겹치는 점에서의 처리가 포인트

먼저 입력을 받을 때부터 R, B인 칸의 좌표를 저장하여 공의 위치에 상수 시간에 접근할 수 있게 한다.
각 좌표 변화량이 담긴 `dy`, `dx` 리스트를 사용해서 순회하기 용이하도록 한다.

각 방향으로 움직여 보고 만약 파란 공이 구멍에 들어갔다면 그 시행은 실패이다. 
파란 공이 구멍에 들어가지 않았고 빨간 공이 구멍에 들어갔다면 그 시행에서 성공한 것이고, 그 시행이 몇 번째인지를 표시하는 `cnt` 변수를 출력한다.

상하좌우로 움직일 때 벽(`#`)과 구멍(`O`)의 여부만 파악하기 때문에 공끼리는 서로 통과가 가능하다. 그래서 이동 결과 두 공이 같은 자리에 있는 경우가 많다. 공은 같은 자리에 있을 수 없으므로 하나의 공을 진행 방향의 역방향으로 1칸만큼 이동시켜 주어야 한다.

이 때 두 공 중 이동 거리가 더 큰 공이 더 뒤에서부터 온 공이므로, 그 공을 이동시킨다. (`BR....#` 일 때 B가 R보다 이동 거리가 더 길다.)

그리고 무한 루프를 피하기 위해 현재 빨간 공과 파란 공의 위치를 `visited` 배열에 저장해 놓고, `q`와 `visited`에 넣기 전 `visited`에 위치가 존재하는지 탐색하는 과정을 거친다.

# 느낀 점
처음에는 상하좌우 4가지 경우를 1번 사용, 2번 사용... 10번 사용해서 중복순열을 만든 뒤 
(ex: '상상하좌우상') 그것대로 움직여 보고 빨간 공만 탈출이 가능한지 여부를 파악했었는데 경우의 수가 너무 많고 하나의 경우의 수당 작업의 시간 복잡도도 상당하여 어마어마한 시간복잡도가 나와 시간 초과를 당했다.

계속 고민해봐도 '이동을 먼저 정하고 움직인다' 라는 생각에서 꽂혀 벗어나지 못한 탓인지 결국 긴 시간이 지나도 풀지 못했고 구글링하여 정답처리 하게 되었다. ㅠㅠ

'코테는 DFS BFS DP만 할 줄 알면 된다' 라는 말을 많이 들었는데 이건 마치 '미적분II는 미분, 적분만 할 줄 알면 된다' 라는 말과 같다...