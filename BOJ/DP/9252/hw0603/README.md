## Info
[9252 LCS 2](https://www.acmicpc.net/problem/9252)

## 💡 풀이 방법 요약
`dp[len(str1)][len(str2)]` 크기의 2차원 리스트를 만들고, 0행과 0열은 모두 0으로 비워 둔다.  
이 때 `dp[i][j]` 는 `str[:i+1]` 과 `str[:j+1]`로 만들 수 있는 LCS의 길이. 즉, 첫 번째 문자열의 i번째 문자 까지와, 두 번째 문자열의 j번째 문자 까지로 만들 수 있는 LCS의 길이를 의미한다.  
  
그렇다면 다음과 같은 점화식이 성립한다.
```
Case #1) 현재 시행에서 추가된 문자가 동일
dp[i][j] = dp[i-1][j-1] + 1  # 이번 시행에서 추가된 문자를 제외한 문자열들의 LCS + 1

Case #2) 현재 시행에서 추가된 문자가 상이
dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # 각 문자가 추가되기 전의 LCS 두 값 중 큰 값
```
루프 종료 이후 `dp[-1][-1]`을 구하면 LCS의 길이가 된다.
  
LCS 원본 수열을 복원하기 위하여 `dp[-1][-1]`에서부터 시작하여 거꾸로 타고 올라가며 dp 배열을 조사한다.  
이때, dp 배열을 생성하는 규칙을 거꾸로 적용하여 `str1[i]`와 `str2[j]`가 같을 경우에는 `dp[i-1][j-1]`로 이동하고, 두 문자가 다를 경우에는 `dp[i-1][j]` 와 `dp[i][j-1]` 중 큰 곳으로 이동한다.  
이동은 i 혹은 j가 0이 될 때 까지 계속 반복하며, 1회 시행 이후 변화한 `i`, `j`에 대하여 `dp[i][j]`의 값이 1 감소했다면 해당 인덱스 정보를 리스트에 저장해 둔다.  
루프 종료 이후 저장된 리스트를 거꾸로 참조하여 출력하면 원본 수열을 구할 수 있다.

## 🙂 느낀 점
None
