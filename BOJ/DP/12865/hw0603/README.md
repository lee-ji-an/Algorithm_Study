## Info
[12865 평범한 배낭](https://www.acmicpc.net/problem/12865)

## 💡 풀이 방법 요약
`dp[N+1][K+1]` 크기의 2차원 배열을 선언하고, `dp[i][j] = i번째 물건까지 조사했을 때, 무게 j로 만들 수 있는 최대 가치 (i, j >0)`로 한다.  
n번째 시행에서, 

1. 현재 물건을 넣는 경우
   - `dp[i][j] = dp[i-1][j-현재 물건의 무게] + 현재 물건의 가치`
   - 지금까지 조사한 경우들 중 현재 물건의 무게를 뺐을 때의 최대 가치 + 현재 물건의 가치
2. 현재 물건을 넣지 않는 경우
   - `dp[i][j] = dp[i-1][j]`
   - 한 단계 이전 시행의 최선의 경우와 동일  

이렇게 두 가지 경우가 존재할 것이다. 기본적으로는 두 가지 경우 중 더 가치가 높은 경우를 택하여 저장하면 된다.  
만약 현재 물건이 너무 무거워서 현재 물건 하나로도 무게 제한을 넘어 버리는 경우에는 배낭에 그 물건을 넣을 수 있는 경우가 없으므로 항상 현재 물건을 넣지 않는 경우로 처리하면 된다.  
  
모든 시행을 마치고 나면 `dp[-1][-1]`에 무게제한이 K일 때, N번째 물건까지 조사했을 경우 가치의 최댓값이 담겨 있을 것이다.


## 🙂 마무리
예전에 풀었을 때는 처음부터 막혀서 풀이를 참고했었는데, 이번에는 한 번에 풀었다. ~~나.. 성장했나?~~
  
물건들을 정렬하고 딕셔너리를 써서 푼 사람들이 시간이 엄청 빠르길래 코드를 봤는데, 도무지 이해가 되지 않는다.. 뭘까

## 개선된 동적 계획법
사실 따지고 보면 `dp[-1][-1]`만 구하면 되는 문제이므로, 해당 위치부터 거꾸로 올라간다고 생각하면 필요한 값들만 구할 수 있다.  
-> 재귀로 구현하여 `dp[-1][-1]`를 구하기 위한 지점들을 쭉쭉 구해나가다가, 모두 구해지면 리턴하면서 값을 더해 나가는 방법  
[2.3절 참고](https://hi-guten-tag.tistory.com/160)
