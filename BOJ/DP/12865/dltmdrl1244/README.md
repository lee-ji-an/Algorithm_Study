## Info
[12865 평범한 배낭](https://www.acmicpc.net/problem/12865)

## 💡 풀이 방법 요약
> 각 무게별 최적 가치를 딕셔너리로 저장
- 각 아이템을 입력받을 때마다, 딕셔너리를 수행하면서 무게가 이 아이템을 넣을 수 있는 무게 즉 `w + cur_w >= k` 인지
확인하고
- 기존에 `w + cur_w` 만큼의 무게를 넣은적이 없어 `bag[w + cur_w]`가 딕셔너리에 존재하지 않거나
`bag[w + cur_w]`의 값이 이 아이템을 넣음으로써 더 가치가 높아진다면 딕셔너리를 수정함
- 이 때 딕셔너리를 순회하는 와중에 딕셔너리를 수정하면 오류가 발생하기 때문에 딕셔너리를 순회하는 와중에는
tmp라는 임시 딕셔너리를 만들고 거기다가 값을 저장한 후 순회가 끝나면 `bag.update(tmp)`를 해줌으로써 `tmp`의 정보를
`bag` 딕셔너리에 옮겨 담는다.

## 🙂 마무리
예전에 풀었을 때도 풀지 못했는데 이번에도 마찬가지로 2차원 dp를 사용해야 한다는 것이 생각나지 않아 풀지 못했다.
`N^2`의 시간 복잡도를 사용하는 2차원 dp를 사용하는 풀이 방법의 경우 다음과 같다.
- `dp[i][j]`를 `i번째 아이템까지 고려했을 때 무게 j를 가장 가치 높게 담았을 때의 가치` 로 정의함
- 아이템을 순회하면서 무게 1부터 k까지 순회하면서 이 아이템을 넣을 수 있는 무게에 대해서는 `이 아이템을 추가했을 때` 와 `기존`의 상태를 비교
하여 더 가치가 높은 케이스를 택함
- 이 아이템을 넣을 수 없는 무게에 대해서는 넣을 수 없으므로 `dp[i][j]` 는 `dp[i-1][j]`의 값을 그대로 넣어 준다.

```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
dp = [[0] * (k+1) for _ in range(n)]
# dp[i][j] = i개의 item을 가지고 j 무게를 가장 효율적으로 채웠을 때 무게
items = [list(map(int, input().split())) for _ in range(n)]

# 무게, 가치 순서

for i in range(n) :
    w, v = items[i]
    for j in range(1, k+1) :
        if w > j : # i번째 item의 무게가 무게제한보다 크면, [i-1][j]
            dp[i][j] = dp[i-1][j]
        else :
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w] + v)

print(dp[-1][k])
```
두 방법 모두 생각하지 못한 나는 바보임