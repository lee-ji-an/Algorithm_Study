## Info
[14391 종이조각](https://www.acmicpc.net/problem/14391)

## 💡 풀이 방법 요약
2차원 배열을 긴 1차원 배열로 생각하고, 0 ~ 2^(N*M) 까지의 모든 비트열을 대상으로 검사를 진행한다.
  
![image.png](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14391/1.png)
가로로 이어짐: `1`, 세로로 이어짐: `0` 으로 생각하면
위 그림과 같은 형태의 board는 다음과 같이 나타낼 수 있다.
```
1 1 1 0
0 0 1 0
0 0 0 0
1 1 0 0
```
이때, 대응되는 비트열은 `1110 0010 0000 1100`이 되는 것이다.  
각 비트열에 대해, 가로와 세로에 맞게 각각 순서대로 조사하며 bit shift + bit and 연산을 통해 현재 조사하고 있는 위치(`idx`)의 비트가 켜져 있는지를 확인하고, 켜져 있다면 `num += 10*num + digit` 과 같이 십진수를 만들어 가며 누적해 준다.  
  
가로와 세로 합을 구한 다음에는 최댓값을 갱신해 주고, 루프 탈출 이후 해당 최댓값을 출력하면 정답

## 🙂 마무리
입력 범위가 작아서 BF로 풀리겠거니.. 했는데 구현이 막막해서 결국 풀이를 참고했다.  
비트마스킹 풀이는 언제나 생각하기 어렵다...
