## Info
[19236 청소년 상어](https://www.acmicpc.net/problem/19236)

## 💡 풀이 방법 요약
DFS 탐색으로 풀이한다.  

1. `space`안에서 물고기의 번호와 방향을 저장한다. 잡아먹힌 물고기는 번호를 `0`으로 마킹할 것이다.
2. DFS탐색하며 상어가 그 방향으로 움직였을 때 먹은 물고기의 번호를 누적해 주고, 최댓값을 갱신한다. (앞서 설명한 것 처럼 먹은 물고기의 번호는 `0`으로 마킹)
3. 상어가 물고기를 먹은 후 다시 물고기의 이동이 발생한다. `space`에서 어떤 물고기의 번호가 존재한다면 먹히지 않은 것이다.
   1. 해당 물고기의 방향대로 이동할 수 있다면 이동하는 곳의 위치와 현재 위치의 `space` 정보를 swap.
   2. 해당 물고기의 방향대로 이동할 수 없다면 이동할 수 있는 곳을 찾을 때 까지 반시계 방향 45도로 회전한다.
4. 물고기가 모두 이동한 후, 상어의 이동이 시작되는데 상어의 현재 방향대로 갈 수 있는 모든 곳에 이동이 가능하면(=물고기가 존재함 and 범위 있음) DFS로 들어가서 물고기를 먹는다.
모든 DFS를 돈 후 상어가 먹은 물고기 번호의 최댓값을 출력한다.
  
말로 적어놓으니까 장황한데 문제에서 시키는 대로 구현하면 풀린다. 추가 시간 없는 1초 문제에 깊은 복사를 써서 좀 걱정했었는데, 맵 자체가 4x4로 그렇게 크지 않아서인지 생각보다 빠른 실행시간으로 풀이할 수 있었다.

## 🙂 마무리
3차원 배열을 깊은 복사 해야 할 일이 생겨서 `copy.deepcopy()`를 사용하지 않고 리스트 컴프리핸션으로 어떻게 표현해야 할지 헷갈려서 고민을 좀 했다.  
  
정답은 `[[r[:] for r in row] for row in board]`  
80ms(`copy.deepcopy()`) -> 60ms(`list comprehension`)
