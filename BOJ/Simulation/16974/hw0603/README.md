## Info
[16974 레벨 햄버거](https://www.acmicpc.net/problem/16974)

## 💡 풀이 방법 요약
![image](https://user-images.githubusercontent.com/31981462/221602513-e8c8121a-1601-44df-a171-971ed0b7c455.png)
`burger[i] = Level-i 버거의 총 재료 개수`, `patty[i] = Level-i 버거의 총 패티 개수`로 정의하고 알맞은 값을 미리 구해 준다.  
```python
burger[n] = 레벨 n의 전체 재료수 = 1 + (레벨 n-1의 전체재료수) + 1 + (레벨 n-1의 전체재료수) + 1
burger[n] = 레벨 n의 패티 수 = (레벨 n-1의 패티수) + 1 + (레벨 n-1의 패티수)
```

버거를 먹을 수 있는 모든 경우의 수를 생각해 보면 다음 4가지 중 하나일 것이다.
1. X값이 중간 패티(`P`)의 위치보다 작은 경우
   - N-1 레벨 버거에서 X-1장(맨 아래 번 하나 뺴고)을 먹는 경우와 같음
2. X값이 중간 패티(`P`)의 위치와 같은 경우
   - N-1 레벨 버거의 패티 개수 + 1(중간 패티) 와 같음
3. X값이 중간 패티(`P`)의 위치보다 크고 전체 재료 수 보다 작은 경우
   - Case #2의 결과값 + (x-중간 패티까지의 재료 수(=중간 패티 이후로 더 먹을 수 있는 재료의 수))
4. X값이 전체 재료 수와 같은 경우
   - N레벨 버거의 패티 개수와 같음

이 4가지 조건을 고려하여 Level-N 버거에서 X장을 먹었을 때, 먹은 패티의 개수를 반환하는 함수인 `eat(N, X)`를 정의하고, 분기 안에서 재귀호출하는 방식을 통해 정답을 도출할 수 있다.


## 🙂 느낀 점
처음엔 컴파일러에서 토큰 DFA를 따라 구현하는 느낌으로 재귀호출을 통해 햄버거 문자열을 미리 만들어 놓고, 앞에서부터 X개를 잘라서 패티 문자(`P`)의 개수를 세는 단순한 방법으로 접근했는데, 마지막 테스트 케이스에서 매우 오래 걸렸다.  
어떻게 단축해야 할지 감이 잘 안 와서 풀이를 참고했는데, X의 범위에 따라 분기하여 필요한 값만 구하는 문제였다..
풀이를 보고 이해는 했지만 내가 처음부터 범위를 잘 나눠서 이렇게 풀 수 있었을지는 의문..
