## Info
[42890 후보키](https://school.programmers.co.kr/learn/courses/30/lessons/42890)

## 💡 풀이 방법 요약
이전 카카오 기출이였던 [순위 검색](https://school.programmers.co.kr/learn/courses/30/lessons/72412) 문제와 같이 데이터를 중복 저장하는 것이 포인트이다.  
사실 기본적인 접근 방법이 거의 유사한데, 나올 수 있는 모든 후보키 조합에 대한 해시를 만들어 두고, 키를 해시로, 값을 'DB에서 해당 후보키 튜플에 대응되는 값' 으로 가지는 딕셔너리를 구축한다.  
이때, 중복된 값을 제거한 후 개수를 세어 고유성을 검증할 것이므로, 딕셔너리는 `defaultdict(set)` 형태로 정의하였다.  
  
딕셔너리 구축이 완료되면 `row`의 개수와 각 `key`에 해당하는 값들의 개수가 동일한지 검사하여 특정 `key`가 유일성을 만족하는지 확인할 수 있고, 따라서 유일성을 만족하는 키들의 리스트(혹은 제네레이터)를 정의할 수 있다.  
  
유일성을 만족하는 키들을 구했으면, 이들 중에서 최소성을 만족하지 못하는 키들을 제외해 주면 된다.  
쉽게 제거하기 위해 제네레이터를 `set`으로 매핑하고, 덱으로 변환한다.  
덱에서 하나를 `.pop()` 한 뒤, 해당 키와 나머지 모든 키들이 부분집합 관계에 있는지를 확인하고, 만약 부분집합 관계가 아니라면 그 키는 유효한 후보키이므로 덱에 다시 삽입해 준다. 이때 삽입된 키가 동일 루프에서 다시 꺼내지는 것을 막기 위하여 덱을 각 시점의 길이를 기준으로 슬라이싱하여 최초 로직 진입 당시에 덱에 존재하던 원소까지만 모두 검사하도록 한다.

## 🙂 마무리
`set.issubset()`을 사용하면 부분집합 관계를 쉽게 확인할 수 있다.  
처음에는 집합이 아닌 문자열로 관리했었는데, `"13" in "123" == False` 와 같은 경우 때문에 최소성을 제대로 판별하지 못하여 틀렸습니다를 받았었다.
