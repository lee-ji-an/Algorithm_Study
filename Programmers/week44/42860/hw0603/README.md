## Info
[42860 조이스틱](https://school.programmers.co.kr/learn/courses/30/lessons/42860)

## 💡 풀이 방법 요약
전달받은 `name`과 `"A"*len(name)` 두 문자열을 비교하여 커서 이동 횟수를 고려하지 않았을 때, `A` 에서 각 인덱스의 문자로 변경하기 위해 소모하는 최소 이동 횟수를 미리 구해둔다. 이때, A-Z가 순환되는 구조이므로 시계방향과 반시계방향 조작 중 작은 값을 취한다.  
  
다음으로는 BFS를 사용하여 방문해야 하는 남은 위치(전체 문자열에서 A가 아닌 문자의 인덱스)에 모두 방문하기까지 걸리는 최소 이동 횟수를 구하여 위에서 구한 값과 합해주면 정답.

## 🙂 마무리
문제 유형에 그리디라고는 하는데 BFS로 풀었다. 입력 범위가 크지 않아 별도로 방문처리도 하지 않았다. 만약 방문처리를 해야 한다면, 풀이에서 사용한 `set`이 unhashable type 이라 문자열 등을 사용하여 직접 해싱하는 과정을 구현하고, 그 해시를 기준으로 방문처리해야 할 듯.  
문제 보자마자 BFS부터 생각이 나서 그리디로는 어떻게 푸는지 잘 안 와 닿는다.
