## Info
[148652 유사 칸토어 비트열](https://school.programmers.co.kr/learn/courses/30/lessons/148652)

## 💡 풀이 방법 요약
처음부터 `num`까지의 유사 칸토어 비트열에서 켜진 비트의 개수를 세는 `bit_count(num)` 을 정의한다. 그럼 `l`부터 `r` 범위에서 켜진 비트의 수는 `bit_count(r) - bit_count(l-1)` 로 구할 수 있다.  
  
`bit_count()` 는 재귀함수로 구현한다.  
`T T F T T` 형태의 패턴 5개가 재귀적으로 반복되는 형태이므로, `n`을 증가시키면서 비트열을 만들다 보면 `n`번째 비트열의 길이는 `5^n` 이고, 그 비트열 중 켜진 비트의 개수는 `4^n`이 됨을 알 수 있다.  
![image](https://github.com/lee-ji-an/Algorithm_Study/assets/31981462/2703d673-76ab-4c50-a32b-51c7728253b7)
  
이 성질을 이용하여 `5^exp` 가 `num`을 넘지 않는 최대의 승수를 구한 뒤, 비트열을 5개의 그룹으로 분할하고, 몇 개의 그룹을 온전히 만족하는지 계산하여 그만큼 `4^exp`를 더해주고, 불완전한 그룹에 해당하는 켜진 비트의 개수를 계산하는 과정을 재귀호출로 위임하여 전체 비트열에서 켜진 비트 개수를 구할 수 있다.
  
```
[예시: bit_count(111)을 계산하는 경우]

5^2 < 111 < 5^3 이므로, maxexp는 2이다.
따라서 온전한 5개의 비트열은 길이가 125짜리 비트열이고, 이는 5^2 개의 비트열 5개 그룹으로 분할될 수 있다. (5^2 * 5 = 5^3)

111 % 25 = 11이고, 111 // 25 = 4 이므로, 그룹 4개를 온전히 만족하고 11개의 비트가 남는다. (25  25  25  25  |  11)
이때, 한 그룹 당 4^2 개의 비트열이 켜져 있으므로, 그룹 개수*4^2를 하면 켜진 비트의 수를 구할 수 있지만, 3번째 그룹은 모두 0으로 구성되어 있으므로 해당 조건을 고려하여 계산한다.

만약 두 개의 그룹을 온전히 만족하는 경우, 나머지가 존재하더라도 3번쨰 그룹이 모두 0이므로 더 계산할 필요 없이 바로 반환하면 되고, 그 이외의 경우 나머지에 대한 켜진 비트 수를 구하기 위해 bit_count(remainder=11)의 반환값을 온전한 그룹의 켜진 비트 개수에 더하여 반환해 주면 된다.
```

## 🙂 마무리
어렵다;; 막상 풀고 나니 `n`에 대한 정보는 필요가 없었다.
